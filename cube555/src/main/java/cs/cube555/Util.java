package cs.cube555;

class Util {
	static final int U1 = 0;
	static final int U2 = 1;
	static final int U3 = 2;
	static final int U4 = 3;
	static final int U5 = 4;
	static final int U6 = 5;
	static final int U7 = 6;
	static final int U8 = 7;
	static final int U9 = 8;
	static final int U10 = 9;
	static final int U11 = 10;
	static final int U12 = 11;
	static final int U13 = 12;
	static final int U14 = 13;
	static final int U15 = 14;
	static final int U16 = 15;
	static final int U17 = 16;
	static final int U18 = 17;
	static final int U19 = 18;
	static final int U20 = 19;
	static final int U21 = 20;
	static final int U22 = 21;
	static final int U23 = 22;
	static final int U24 = 23;
	static final int U25 = 24;
	static final int R1 = 25;
	static final int R2 = 26;
	static final int R3 = 27;
	static final int R4 = 28;
	static final int R5 = 29;
	static final int R6 = 30;
	static final int R7 = 31;
	static final int R8 = 32;
	static final int R9 = 33;
	static final int R10 = 34;
	static final int R11 = 35;
	static final int R12 = 36;
	static final int R13 = 37;
	static final int R14 = 38;
	static final int R15 = 39;
	static final int R16 = 40;
	static final int R17 = 41;
	static final int R18 = 42;
	static final int R19 = 43;
	static final int R20 = 44;
	static final int R21 = 45;
	static final int R22 = 46;
	static final int R23 = 47;
	static final int R24 = 48;
	static final int R25 = 49;
	static final int F1 = 50;
	static final int F2 = 51;
	static final int F3 = 52;
	static final int F4 = 53;
	static final int F5 = 54;
	static final int F6 = 55;
	static final int F7 = 56;
	static final int F8 = 57;
	static final int F9 = 58;
	static final int F10 = 59;
	static final int F11 = 60;
	static final int F12 = 61;
	static final int F13 = 62;
	static final int F14 = 63;
	static final int F15 = 64;
	static final int F16 = 65;
	static final int F17 = 66;
	static final int F18 = 67;
	static final int F19 = 68;
	static final int F20 = 69;
	static final int F21 = 70;
	static final int F22 = 71;
	static final int F23 = 72;
	static final int F24 = 73;
	static final int F25 = 74;
	static final int D1 = 75;
	static final int D2 = 76;
	static final int D3 = 77;
	static final int D4 = 78;
	static final int D5 = 79;
	static final int D6 = 80;
	static final int D7 = 81;
	static final int D8 = 82;
	static final int D9 = 83;
	static final int D10 = 84;
	static final int D11 = 85;
	static final int D12 = 86;
	static final int D13 = 87;
	static final int D14 = 88;
	static final int D15 = 89;
	static final int D16 = 90;
	static final int D17 = 91;
	static final int D18 = 92;
	static final int D19 = 93;
	static final int D20 = 94;
	static final int D21 = 95;
	static final int D22 = 96;
	static final int D23 = 97;
	static final int D24 = 98;
	static final int D25 = 99;
	static final int L1 = 100;
	static final int L2 = 101;
	static final int L3 = 102;
	static final int L4 = 103;
	static final int L5 = 104;
	static final int L6 = 105;
	static final int L7 = 106;
	static final int L8 = 107;
	static final int L9 = 108;
	static final int L10 = 109;
	static final int L11 = 110;
	static final int L12 = 111;
	static final int L13 = 112;
	static final int L14 = 113;
	static final int L15 = 114;
	static final int L16 = 115;
	static final int L17 = 116;
	static final int L18 = 117;
	static final int L19 = 118;
	static final int L20 = 119;
	static final int L21 = 120;
	static final int L22 = 121;
	static final int L23 = 122;
	static final int L24 = 123;
	static final int L25 = 124;
	static final int B1 = 125;
	static final int B2 = 126;
	static final int B3 = 127;
	static final int B4 = 128;
	static final int B5 = 129;
	static final int B6 = 130;
	static final int B7 = 131;
	static final int B8 = 132;
	static final int B9 = 133;
	static final int B10 = 134;
	static final int B11 = 135;
	static final int B12 = 136;
	static final int B13 = 137;
	static final int B14 = 138;
	static final int B15 = 139;
	static final int B16 = 140;
	static final int B17 = 141;
	static final int B18 = 142;
	static final int B19 = 143;
	static final int B20 = 144;
	static final int B21 = 145;
	static final int B22 = 146;
	static final int B23 = 147;
	static final int B24 = 148;
	static final int B25 = 149;

	static final byte Ux1 = 0;
	static final byte Ux2 = 1;
	static final byte Ux3 = 2;
	static final byte Rx1 = 3;
	static final byte Rx2 = 4;
	static final byte Rx3 = 5;
	static final byte Fx1 = 6;
	static final byte Fx2 = 7;
	static final byte Fx3 = 8;
	static final byte Dx1 = 9;
	static final byte Dx2 = 10;
	static final byte Dx3 = 11;
	static final byte Lx1 = 12;
	static final byte Lx2 = 13;
	static final byte Lx3 = 14;
	static final byte Bx1 = 15;
	static final byte Bx2 = 16;
	static final byte Bx3 = 17;
	static final byte ux1 = 18;
	static final byte ux2 = 19;
	static final byte ux3 = 20;
	static final byte rx1 = 21;
	static final byte rx2 = 22;
	static final byte rx3 = 23;
	static final byte fx1 = 24;
	static final byte fx2 = 25;
	static final byte fx3 = 26;
	static final byte dx1 = 27;
	static final byte dx2 = 28;
	static final byte dx3 = 29;
	static final byte lx1 = 30;
	static final byte lx2 = 31;
	static final byte lx3 = 32;
	static final byte bx1 = 33;
	static final byte bx2 = 34;
	static final byte bx3 = 35;

	static final String[] move2str = new String[] {
	    "U ", "U2", "U'", "R ", "R2", "R'", "F ", "F2", "F'",
	    "D ", "D2", "D'", "L ", "L2", "L'", "B ", "B2", "B'",
	    "u ", "u2", "u'", "r ", "r2", "r'", "f ", "f2", "f'",
	    "d ", "d2", "d'", "l ", "l2", "l'", "b ", "b2", "b'"
	};

	static int[][] Cnk = new int[25][25];
	static int[] fact = new int[13];

	static {
		for (int i = 0; i < 25; i++) {
			Cnk[i][i] = 1;
			Cnk[i][0] = 1;
		}
		for (int i = 1; i < 25; i++) {
			for (int j = 1; j <= i; j++) {
				Cnk[i][j] = Cnk[i - 1][j] + Cnk[i - 1][j - 1];
			}
		}
		fact[0] = 1;
		for (int i = 1; i < 13; i++) {
			fact[i] = fact[i - 1] * i;
		}
	}

	static long[] genSkipMoves(int[] VALID_MOVES) {
		long[] ret = new long[VALID_MOVES.length + 1];
		for (int last = 0; last < VALID_MOVES.length; last++) {
			ret[last] = 0;
			int la = VALID_MOVES[last] / 3;
			for (int move = 0; move < VALID_MOVES.length; move++) {
				int axis = VALID_MOVES[move] / 3;
				if (axis == la || axis % 3 == la % 3 && axis >= la) {
					ret[last] |= 1 << move;
				}
			}
		}
		return ret;
	}

	static long genNextAxis(int[] VALID_MOVES) {
		long ret = 0;
		for (int i = 0; i < VALID_MOVES.length; i++) {
			if (VALID_MOVES[i] % 3 == 0) {
				//if Mx1 makes state farther, Mx2 and Mx3 should be skipped
				// (next_axis >> i & 3) == 2 for Mx1, 1 for Mx2, 0 for Mx3
				ret |= 1L << (i + 1);
			}
		}
		return ret;
	}

	static int[] setPerm(int[] arr, int idx, int n, boolean even) {
		long val = 0xFEDCBA9876543210L;
		int parity = 0;
		if (even) {
			idx <<= 1;
		}
		n--;
		for (int i = 0; i < n; ++i) {
			int p = fact[n - i];
			int v = ~~(idx / p);
			parity ^= v;
			idx %= p;
			v <<= 2;
			arr[i] = (int) (val >> v & 0xf);
			long m = (1L << v) - 1;
			val = (val & m) + (val >> 4 & ~m);
		}
		if (even && (parity & 1) != 0) {
			arr[n] = arr[n - 1];
			arr[n - 1] = (int) (val & 0xf);
		} else {
			arr[n] = (int) (val & 0xf);
		}
		return arr;
	}

	static int[] setPerm(int[] arr, int idx, int n) {
		return setPerm(arr, idx, n, false);
	}

	static int[] setPerm(int[] arr, int idx) {
		return setPerm(arr, idx, arr.length, false);
	}

	static int getPerm(int[] arr, int n, boolean even) {
		int idx = 0;
		long val = 0xFEDCBA9876543210L;
		for (int i = 0; i < n - 1; ++i) {
			int v = arr[i] << 2;
			idx = (n - i) * idx + (int) (val >> v & 0xf);
			val -= 0x1111111111111110L << v;
		}
		return even ? (idx >> 1) : idx;
	}

	static int getPerm(int[] arr, int n) {
		return getPerm(arr, n, false);
	}

	static int getPerm(int[] arr) {
		return getPerm(arr, arr.length, false);
	}

	static int[] setComb(int[] arr, int idx, int r, int n) {
		for (int i = n - 1; i >= 0; i--) {
			if (idx >= Cnk[i][r]) {
				idx -= Cnk[i][r--];
				arr[i] = 0;
			} else {
				arr[i] = -1;
			}
		}
		return arr;
	}

	static int[] setComb(int[] arr, int idx, int r) {
		return setComb(arr, idx, r, arr.length);
	}

	static int getComb(int[] arr, int r, int n) {
		int idx = 0;
		for (int i = n - 1; i >= 0; i--) {
			if (arr[i] != -1) {
				idx += Cnk[i][r--];
			}
		}
		return idx;
	}

	static int getComb(int[] arr, int r) {
		return getComb(arr, r, arr.length);
	}

	static int getSComb(int[] arr, int n) {
		int idx = 0;
		int r = n / 2;
		for (int i = n - 1; i >= 0; i--) {
			if (arr[i] != arr[n - 1]) {
				idx += Cnk[i][r--];
			}
		}
		return idx;
	}

	static int getSComb(int[] arr) {
		return getSComb(arr, arr.length);
	}

	static void copyFromComb(int[] src, int[] dst) {
		int r = 0;
		for (int i = 0; i < src.length; i++) {
			if (src[i] != -1) {
				dst[r++] = src[i];
			}
		}
	}

	static void copyToComb(int[] src, int[] dst) {
		int r = 0;
		for (int i = 0; i < dst.length; i++) {
			if (dst[i] != -1) {
				dst[i] = src[r++];
			}
		}
	}

	static int getParity(int idx, int n) {
		int parity = 0;
		for (int i = n - 2; i >= 0; --i) {
			parity ^= idx % (n - i);
			idx /= n - i;
		}
		return parity & 1;
	}

	static int getParity(int[] arr) {
		int parity = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[i] > arr[j]) {
					parity ^= 1;
				}
			}
		}
		return parity;
	}

	static void swap(int[] arr, int a, int b) {
		int temp = arr[a];
		arr[a] = arr[b];
		arr[b] = temp;
	}

	static void swapCorner(int[] arr, int a, int b, int c, int d, int pow) {
		int temp;
		switch (pow) {
		case 0:
			temp = (arr[d] + 8) % 24;
			arr[d] = (arr[c] + 16) % 24;
			arr[c] = (arr[b] + 8) % 24;
			arr[b] = (arr[a] + 16) % 24;
			arr[a] = temp;
			return;
		case 1:
			temp = arr[a];
			arr[a] = arr[c];
			arr[c] = temp;
			temp = arr[b];
			arr[b] = arr[d];
			arr[d] = temp;
			return;
		case 2:
			temp = (arr[a] + 8) % 24;
			arr[a] = (arr[b] + 16) % 24;
			arr[b] = (arr[c] + 8) % 24;
			arr[c] = (arr[d] + 16) % 24;
			arr[d] = temp;
			return;
		}
	}

	static void swap(int[] arr, int a, int b, int c, int d, int pow, boolean flip) {
		int xor = flip ? 1 : 0;
		int temp;
		switch (pow) {
		case 0:
			temp = arr[d] ^ xor;
			arr[d] = arr[c] ^ xor;
			arr[c] = arr[b] ^ xor;
			arr[b] = arr[a] ^ xor;
			arr[a] = temp;
			return;
		case 1:
			temp = arr[a];
			arr[a] = arr[c];
			arr[c] = temp;
			temp = arr[b];
			arr[b] = arr[d];
			arr[d] = temp;
			return;
		case 2:
			temp = arr[a] ^ xor;
			arr[a] = arr[b] ^ xor;
			arr[b] = arr[c] ^ xor;
			arr[c] = arr[d] ^ xor;
			arr[d] = temp;
			return;
		}
	}

	static void swap(int[] arr, int a, int b, int c, int d, int pow) {
		swap(arr, a, b, c, d, pow, false);
	}

	static int indexOf(int[] arr, int value) {
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value) {
				return i;
			}
		}
		return -1;
	}

	static abstract class Coord {
		int N_IDX = 1;
		int N_MOVES = 0;
		int idx;
		void set(int idx) {
			this.idx = idx;
		}
		abstract int getMoved(int move);
	}

	static abstract class SymCoord extends Coord {
		int N_SYM;
		int[] SelfSym;
	}

	static abstract class RawCoord extends Coord {
		int getConj(int idx, int conj) {
			return idx;
		}
	}

	static class TableSymCoord extends SymCoord {
		int[][] moveTable;
		TableSymCoord(int[][] moveTable, int[] SelfSym, int N_SYM) {
			this.moveTable = moveTable;
			this.SelfSym = SelfSym;
			this.N_SYM = N_SYM;
			this.N_IDX = moveTable.length;
			this.N_MOVES = moveTable[0].length;
		}
		int getMoved(int move) {
			return moveTable[idx][move];
		}
	}

	static class TableRawCoord extends RawCoord {
		int[][] moveTable;
		int[][] conjTable;
		TableRawCoord(int[][] moveTable, int[][] conjTable) {
			this.moveTable = moveTable;
			this.conjTable = conjTable;
			this.N_IDX = moveTable.length;
			this.N_MOVES = moveTable[0].length;
		}
		int getMoved(int move) {
			return moveTable[idx][move];
		}
		int getConj(int idx, int conj) {
			return conjTable[idx][conj];
		}
	}

	static int[][] packSolved(int[] Solved1, int[] Solved2) {
		if (Solved1 == null) {
			Solved1 = new int[] {0};
		}
		if (Solved2 == null) {
			Solved2 = new int[] {0};
		}
		int[][] Solved = new int[Solved1.length * Solved2.length][];
		int idx = 0;
		for (int idx1 : Solved1) {
			for (int idx2 : Solved2) {
				Solved[idx++] = new int[] {idx1, idx2};
			}
		}
		return Solved;
	}

	static class PruningTable {
		int N_STATE;
		int N_STATE2;
		int[] Prun;
		int TABLE_MASK = 0x7fffffff;

		private static void setPrun(int[] Prun, int idx, int xorval) {
			Prun[idx >> 3] ^= xorval << (idx << 2);
		}

		private static int getPrun(int[] Prun, int idx) {
			return Prun[idx >> 3] >> (idx << 2) & 0xf;
		}

		PruningTable(Coord coord, int[] Solved, String filename) {
			initPrunTable(coord, Solved, filename);
		}

		PruningTable(SymCoord coord, int[] Solved, String filename) {
			if (Solved == null) {
				Solved = new int[] {0};
			}
			int[][] Solved2 = new int[Solved.length][2];
			for (int i = 0; i < Solved.length; i++) {
				Solved2[i][0] = Solved[i];
			}
			initPrunTable(coord, new RawCoord() {
				int getMoved(int move) {
					return 0;
				}
			}, Solved2, filename);
		}

		PruningTable(SymCoord symCoord, RawCoord rawCoord, int[][] Solved, String filename) {
			initPrunTable(symCoord, rawCoord, Solved, filename);
		}

		PruningTable(SymCoord symCoord, RawCoord rawCoord, int[][] Solved, int maxl, int TABLE_SIZE, String filename) {
			initPrunTablePartial(symCoord, rawCoord, Solved, maxl, TABLE_SIZE, filename);
		}

		PruningTable(int[][] Move, int[] Solved, String filename) {
			initPrunTable(new TableRawCoord(Move, null), Solved, filename);
		}

		PruningTable(final int[][] Move1, final int[][] Move2, int[] Solved1, int[] Solved2, String filename) {
			N_STATE2 = Move2.length;
			N_STATE = Move1.length * Move2.length;
			if (Solved1 == null) {
				Solved1 = new int[] {0};
			}
			if (Solved2 == null) {
				Solved2 = new int[] {0};
			}
			int[] Solved = new int[Solved1.length * Solved2.length];
			int idx = 0;
			for (int idx1 : Solved1) {
				for (int idx2 : Solved2) {
					Solved[idx++] = idx1 * N_STATE2 + idx2;
				}
			}
			initPrunTable(new Coord() {
				{
					N_IDX = Move1.length * Move2.length;
					N_MOVES = Move1[0].length;
				}
				int state2 = 0;
				void set(int i) {
					idx = i / N_STATE2;
					state2 = i % N_STATE2;
				}
				int getMoved(int move) {
					return Move1[idx][move] * N_STATE2 + Move2[state2][move];
				}
			}, Solved, filename);
		}

		private void initPrunTablePartial(SymCoord symCoord, RawCoord rawCoord, int[][] Solved, int maxl, int TABLE_SIZE, String filename) {
			N_STATE = symCoord.N_IDX * rawCoord.N_IDX;
			N_STATE2 = rawCoord.N_IDX;
			int N_SYM = symCoord.N_SYM;
			int N_MOVES = symCoord.N_MOVES;
			TABLE_MASK = TABLE_SIZE - 1;
			Prun = (int[]) Tools.LoadFromFile(filename + "Prun.jpdata");
			if (Prun != null) {
				return;
			}
			if (Solved == null) {
				Solved = new int[][] {{0, 0}};
			}
			java.util.HashMap<Long, Byte> PrunP = new java.util.HashMap<Long, Byte>();
			int done = 0;
			long realDone = 0;
			int depth = 0;
			for (int[] val : Solved) {
				long idx = val[0] * (long) N_STATE2 + val[1];
				PrunP.put(idx, (byte) 0);
				done++;
				realDone += N_SYM / Integer.bitCount(symCoord.SelfSym[val[0]]);
			}
			int cumDone = done;
			long cumRealDone = cumDone;
			long startTime = System.nanoTime();
			do {
				System.out.println(String.format("%s:%2d%,14d%,14d%,16d%,16d%10dms", filename,
				                                 depth, done, cumDone, realDone, cumRealDone,
				                                 (System.nanoTime() - startTime) / 1000000));
				done = 0;
				realDone = 0;
				byte fill = (byte) (depth + 1);
				java.util.HashMap<Long, Byte> PrunPClone = (java.util.HashMap<Long, Byte>) PrunP.clone();
				for (java.util.Map.Entry<Long, Byte> entry : PrunPClone.entrySet()) {
					if (entry.getValue() != depth) {
						continue;
					}
					long i = entry.getKey();
					symCoord.set((int) (i / N_STATE2));
					rawCoord.set((int) (i % N_STATE2));
					for (int m = 0; m < N_MOVES; m++) {
						int newSym = symCoord.getMoved(m);
						int newRaw = rawCoord.getConj(rawCoord.getMoved(m), newSym % N_SYM);
						newSym /= N_SYM;
						long newIdx = newSym * (long) N_STATE2 + newRaw;
						if (PrunP.putIfAbsent(newIdx, fill) != null) {
							continue;
						}
						done++;
						realDone += N_SYM / Integer.bitCount(symCoord.SelfSym[newSym]);
						for (int j = 1, symState = symCoord.SelfSym[newSym]; (symState >>= 1) != 0; j++) {
							if ((symState & 1) != 1) {
								continue;
							}
							long newIdx2 = newSym * (long) N_STATE2 + rawCoord.getConj(newRaw, j);
							if (PrunP.putIfAbsent(newIdx2, fill) != null) {
								continue;
							}
							done++;
							realDone += N_SYM / Integer.bitCount(symCoord.SelfSym[newSym]);
						}
					}
				}
				cumDone += done;
				cumRealDone += realDone;
				depth++;
			} while (done > 0 && depth < maxl);
			System.out.println(String.format("%s:%2d%,14d%,14d%,16d%,16d%10dms", filename,
			                                 depth, done, cumDone, realDone, cumRealDone,
			                                 (System.nanoTime() - startTime) / 1000000));

			Prun = new int[TABLE_SIZE >> 3];
			for (int i = 0; i < Prun.length; i++) {
				Prun[i] = 0x11111111 * (maxl + 1);
			}
			for (java.util.Map.Entry<Long, Byte> entry : PrunP.entrySet()) {
				int idx = (int) (entry.getKey() & TABLE_MASK);
				int val = entry.getValue();
				int prun = getPrun(Prun, idx);
				if (val < prun) {
					setPrun(Prun, idx, val ^ prun);
				}
			}
			int[] depthCnt = new int[16];
			for (int i = 0; i < TABLE_SIZE; i++) {
				depthCnt[getPrun(Prun, i)]++;
			}
			for (int i = 0; i < 16; i++) {
				if (depthCnt[i] != 0) {
					System.out.println(String.format("%s-%2d%,14d", filename, i, depthCnt[i]));
				}
			}
			Tools.SaveToFile(filename + "Prun.jpdata", Prun);
		}

		private void initPrunTable(SymCoord symCoord, RawCoord rawCoord, int[][] Solved, String filename) {
			N_STATE = symCoord.N_IDX * rawCoord.N_IDX;
			N_STATE2 = rawCoord.N_IDX;
			int N_SYM = symCoord.N_SYM;
			int N_MOVES = symCoord.N_MOVES;
			Prun = (int[]) Tools.LoadFromFile(filename + "Prun.jhdata");
			if (Prun != null) {
				return;
			}
			if (Solved == null) {
				Solved = new int[][] {{0, 0}};
			}
			Prun = new int[(N_STATE + 7) / 8];
			for (int i = 0; i < Prun.length; i++) {
				Prun[i] = -1;
			}
			int done = 0;
			long realDone = 0;
			int depth = 0;
			for (int[] val : Solved) {
				int idx = val[0] * N_STATE2 + val[1];
				setPrun(Prun, idx, 0xf);
				done++;
				realDone += N_SYM / Integer.bitCount(symCoord.SelfSym[val[0]]);
			}
			int cumDone = done;
			long cumRealDone = cumDone;
			long startTime = System.nanoTime();
			do {
				System.out.println(String.format("%s:%2d%,14d%,14d%,16d%,16d%10dms", filename,
				                                 depth, done, cumDone, realDone, cumRealDone,
				                                 (System.nanoTime() - startTime) / 1000000));
				done = 0;
				realDone = 0;
				boolean inv = cumDone > N_STATE / 2;
				// boolean inv = true;
				int select = inv ? 0xf : depth;
				int check = inv ? depth : 0xf;
				int fill = depth + 1;
				depth++;
				int val = 0;
				for (int i = 0; i < N_STATE; i++, val >>= 4) {
					if ((i & 7) == 0) {
						val = Prun[i >> 3];
						if (!inv && val == -1) {
							i += 7;
							continue;
						}
					}
					if ((val & 0xf) != select) {
						continue;
					}
					symCoord.set(i / N_STATE2);
					rawCoord.set(i % N_STATE2);
					for (int m = 0; m < N_MOVES; m++) {
						int newSym = symCoord.getMoved(m);
						int newRaw = rawCoord.getConj(rawCoord.getMoved(m), newSym % N_SYM);
						newSym /= N_SYM;
						int newIdx = newSym * N_STATE2 + newRaw;
						if (getPrun(Prun, newIdx) != check) {
							continue;
						}
						done++;
						if (inv) {
							setPrun(Prun, i, fill ^ 0xf);
							realDone += N_SYM / Integer.bitCount(symCoord.SelfSym[i / N_STATE2]);
							break;
						}
						setPrun(Prun, newIdx, fill ^ 0xf);
						realDone += N_SYM / Integer.bitCount(symCoord.SelfSym[newSym]);

						for (int j = 1, symState = symCoord.SelfSym[newSym]; (symState >>= 1) != 0; j++) {
							if ((symState & 1) != 1) {
								continue;
							}
							int newIdx2 = newSym * N_STATE2 + rawCoord.getConj(newRaw, j);
							if (getPrun(Prun, newIdx2) != check) {
								continue;
							}
							setPrun(Prun, newIdx2, fill ^ 0xf);
							done++;
							realDone += N_SYM / Integer.bitCount(symCoord.SelfSym[newSym]);
						}
					}
				}
				cumDone += done;
				cumRealDone += realDone;
			} while (done > 0 && depth < 15);
			Tools.SaveToFile(filename + "Prun.jhdata", Prun);
		}

		private void initPrunTable(Coord coord, int[] Solved, String filename) {
			N_STATE = coord.N_IDX;
			Prun = (int[]) Tools.LoadFromFile(filename + "Prun.jhdata");
			if (Prun != null) {
				return;
			}
			if (Solved == null) {
				Solved = new int[] {0};
			}
			Prun = new int[(N_STATE + 7) / 8];
			for (int i = 0; i < Prun.length; i++) {
				Prun[i] = -1;
			}
			int done = 0;
			int depth = 0;
			for (int idx : Solved) {
				setPrun(Prun, idx, 0xf);
				done++;
			}
			long startTime = System.nanoTime();
			int cumDone = done;
			do {
				System.out.println(String.format("%s:%2d%,14d%,14d%10dms", filename,
				                                 depth, done, cumDone,
				                                 (System.nanoTime() - startTime) / 1000000));
				done = 0;
				boolean inv = cumDone > N_STATE / 2;
				int select = inv ? 0xf : depth;
				int check = inv ? depth : 0xf;
				int fill = depth + 1;
				depth++;
				int val = 0;
				for (int i = 0; i < N_STATE; i++, val >>= 4) {
					if ((i & 7) == 0) {
						val = Prun[i >> 3];
						if (!inv && val == -1) {
							i += 7;
							continue;
						}
					}
					if ((val & 0xf) != select) {
						continue;
					}
					coord.set(i);
					for (int m = 0; m < coord.N_MOVES; m++) {
						int newIdx = coord.getMoved(m);
						if (getPrun(Prun, newIdx) != check) {
							continue;
						}
						done++;
						if (inv) {
							setPrun(Prun, i, fill ^ 0xf);
							break;
						}
						setPrun(Prun, newIdx, fill ^ 0xf);
					}
				}
				cumDone += done;
			} while (done > 0 && depth <= 15);
			Tools.SaveToFile(filename + "Prun.jhdata", Prun);
		}

		int getPrun(int state1, int state2) {
			return getPrun(Prun, (state1 * N_STATE2 + state2) & TABLE_MASK);
		}

		int getPrun(int state) {
			return getPrun(Prun, state & TABLE_MASK);
		}
	}
}